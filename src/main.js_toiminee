import "./w.min.full.js";
import { map1 } from "./maps/maps.js";
import noppa from "./assets/noppa2.png";

const canvas = document.getElementById("myCanvas");
const gl = canvas.getContext("webgl2");

// ----- Perusasetukset -----
const TILE_SIZE = 1;
const EPS = 0.001; // pieni epsilon reunojen välttämiseksi
const GRAVITY = -0.015; // alaspäin (y kasvaa ylöspäin)
const JUMP_FORCE = 0.25;
const MAX_FALL_SPEED = -0.25; // maksimipudotus
const FRAME_TIME = 1000 / 30; // 30 FPS ~ 33 ms

const MAP_H = map1.length;
const MAP_W = map1[0].length;

// Kamera
let z = 10;
let rot = 0;

// ----- Pelaaja: 1x1 tile, koordinaatti = vasen-alakulma -----
let player = {
  x: 8, // vasen
  y: 20, // ala
  w: 1,
  h: 1,
  speed: 0.06,
  vy: 0,
  onGround: false,
};

let keys = {};
let image = new Image();
image.src = noppa;

// ----- Apurit: törmäys -----

// HUOM: kartta on "bottom-up": map1[0] on alin rivi.
// Siksi maailman tileY 0 vastaa suoraan map1[0].
function isSolid(tx, ty) {
  if (tx < 0 || tx >= MAP_W) return false;
  if (ty < 0 || ty >= MAP_H) return false;
  return map1[ty][tx] === "#"; // "#" = seinä/maa
}

// Akseli kerrallaan, kuten klassisissa tile-collidereissa.
// x,y = pelaajan vasen-alakulma. w,h = koko. dx,dy = liike askelessa.
function moveAndCollide(x, y, w, h, dx, dy) {
  // --- X-akseli ---
  let newX = x + dx;
  let collidedX = false;

  let leftTile = Math.floor(newX / TILE_SIZE);
  let rightTile = Math.floor((newX + w - EPS) / TILE_SIZE);
  let bottomTile = Math.floor(y / TILE_SIZE);
  let topTile = Math.floor((y + h - EPS) / TILE_SIZE);

  for (let ty = bottomTile; ty <= topTile; ty++) {
    if (dx > 0) {
      if (isSolid(rightTile, ty)) {
        collidedX = true;
        newX = rightTile * TILE_SIZE - w; // pysäytä seinän vasemmalle puolelle
        break;
      }
    } else if (dx < 0) {
      if (isSolid(leftTile, ty)) {
        collidedX = true;
        newX = (leftTile + 1) * TILE_SIZE; // pysäytä seinän oikealle puolelle
        break;
      }
    }
  }

  x = newX;

  // --- Y-akseli ---
  let newY = y + dy;
  let collidedY = false;

  leftTile = Math.floor(x / TILE_SIZE);
  rightTile = Math.floor((x + w - EPS) / TILE_SIZE);
  bottomTile = Math.floor(newY / TILE_SIZE);
  topTile = Math.floor((newY + h - EPS) / TILE_SIZE);

  for (let tx = leftTile; tx <= rightTile; tx++) {
    if (dy > 0) {
      // ylöspäin
      if (isSolid(tx, topTile)) {
        collidedY = true;
        newY = topTile * TILE_SIZE - h; // pelaajan yläreuna juuri katon alapuolelle
        break;
      }
    } else if (dy < 0) {
      // alaspäin
      if (isSolid(tx, bottomTile)) {
        collidedY = true;
        newY = (bottomTile + 1) * TILE_SIZE; // pelaajan alareuna juuri lattian yläpuolelle
        break;
      }
    }
  }

  return { x, y: newY, collidedX, collidedY };
}

// ----- Syöte -----
document.addEventListener("keydown", (e) => {
  const k = e.code === "Space" ? "Space" : e.key.toLowerCase();
  keys[k] = true;
});
document.addEventListener("keyup", (e) => {
  const k = e.code === "Space" ? "Space" : e.key.toLowerCase();
  keys[k] = false;
});

// ----- Peli-silmukka 30 FPS -----
let lastTime = 0;

function gameLoop(ts) {
  if (ts - lastTime >= FRAME_TIME) {
    update();
    draw();
    lastTime = ts;
  }
  requestAnimationFrame(gameLoop);
}

function update() {
  let dx = 0;
  if (keys["a"] && !keys["d"]) dx = -player.speed;
  if (keys["d"] && !keys["a"]) dx = player.speed;

  // Hyppy vain maasta
  if ((keys[" "] || keys["Space"]) && player.onGround) {
    player.vy = JUMP_FORCE;
    player.onGround = false;
  }

  // Painovoima + putoamisnopeuden rajoitus
  player.vy += GRAVITY;
  if (player.vy < MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;

  const res = moveAndCollide(
    player.x,
    player.y,
    player.w,
    player.h,
    dx,
    player.vy,
  );

  player.x = res.x;
  player.y = res.y;

  // Maassa / katossa
  if (res.collidedY && player.vy < 0) {
    player.onGround = true;
    player.vy = 0;
  } else if (res.collidedY && player.vy > 0) {
    player.vy = 0;
  } else {
    player.onGround = false;
  }
}

function draw() {
  // Kamera pelaajan keskelle
  W.camera({
    ry: rot,
    x: player.x + player.w / 2,
    y: player.y + player.h / 2,
    z: z,
  });

  // Piirrä "pelaaja" (näytetään keskitettynä, jotta 1x1 sopii tileen nätisti)
  W.sphere({
    n: "player",
    size: 1,
    x: player.x + player.w / 2,
    y: player.y + player.h / 2,
    z: 0,
  });
}

// ----- Maailma -----
W.reset(canvas);
W.ambient(0.7);
W.clearColor("8Af");
W.camera({ ry: rot });
W.light({ x: 0.5, y: -0.3, z: -0.5 });

image.onload = function () {
  // Bottom-up: index 0 = alin rivi → y = index
  for (let y = 0; y < MAP_H; y++) {
    const row = map1[y];
    for (let x = 0; x < MAP_W; x++) {
      const ch = row[x];
      if (ch === "#" || ch === "=") {
        W.cube({
          n: `kuutio_${y}_${x}`,
          // W.cube:n x,y ovat objektin keskipiste → siirretään 0.5 jotta tiili osuu ruutuun [x, x+1] × [y, y+1]
          x: x + 0.5,
          y: y + 0.5,
          z: 0,
          w: 1,
          h: 1,
          d: 1,
          t: image,
        });
      } else if (ch === "!") {
        W.sphere({
          n: `ball_${y}_${x}`,
          size: 1,
          x: x + 0.5,
          y: y + 0.5,
          z: 0,
          t: image,
        });
      }
    }
  }
};

requestAnimationFrame(gameLoop);
